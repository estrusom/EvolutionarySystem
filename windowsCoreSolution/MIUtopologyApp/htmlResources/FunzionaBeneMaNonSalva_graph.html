<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grafico 3D</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #f0f0f0; color: #333; }
        canvas { display: block; }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            line-height: 1.5;
            max-width: 300px;
            display: none;
            z-index: 1000; /* Assicura che sia sopra il canvas */
        }
    </style>
</head>
<body>
    <div id="info-panel"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Setup della scena Three.js ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Aggiungi luci per una migliore visualizzazione
        const light = new THREE.PointLight(0xffffff, 1, 1000);
        light.position.set(0, 0, 100);
        scene.add(light);
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        let nodes = [];
        let links = [];
        let linkObjects = [];
        let nodeObjects = [];
        let labelObjects = [];

        const infoPanel = document.getElementById('info-panel');

        // --- Funzione di ridimensionamento ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize, false);

        // --- Funzione per aggiornare il grafico ---
        window.updateGraph = function(data) {
            console.log("Dati del grafico ricevuti:", data);
            
            // Pulisci la scena precedente
            nodeObjects.forEach(obj => scene.remove(obj));
            linkObjects.forEach(obj => scene.remove(obj));
            labelObjects.forEach(label => scene.remove(label));
            nodeObjects = [];
            linkObjects = [];
            labelObjects = [];
            nodes = data.nodes;
            links = data.links;

            if (nodes.length === 0) {
                console.warn("Nessun nodo da disegnare.");
                return;
            }

            // Parametri del nastro di Moebius
            const radius = 50;
            const width = 20;

            // Mappa i nodi alle coordinate del nastro di Moebius
            nodes.forEach((node, index) => {
                // Usa l'indice del nodo per calcolare la sua posizione sul nastro
                const u = (index / nodes.length) * 2 * Math.PI; // Mappa l'indice all'angolo
                const v = ((Math.random() - 0.5) * width) / 2; // Posizione casuale lungo la larghezza

                // Equazioni parametriche del nastro di Moebius
                const x = (radius + v * Math.cos(u / 2)) * Math.cos(u);
                const y = (radius + v * Math.cos(u / 2)) * Math.sin(u);
                const z = v * Math.sin(u / 2);
                
                // Creazione del nodo (sfera)
                const geometry = new THREE.SphereGeometry(1.5, 32, 32);
                const material = new THREE.MeshPhongMaterial({ color: 0x0077ff, specular: 0x5c5c5c, shininess: 30 });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(x, y, z);
                scene.add(sphere);
                nodeObjects.push(sphere);
                node.object = sphere;

                // Creazione dell'etichetta (testo)
                const textCanvas = document.createElement('canvas');
                const context = textCanvas.getContext('2d');
                context.font = '24px Arial';
                const textWidth = context.measureText(node.name).width;
                textCanvas.width = textWidth + 10;
                textCanvas.height = 30;
                context.font = '24px Arial';
                context.fillStyle = 'rgba(0, 0, 0, 1)';
                context.fillText(node.name, 5, 25);

                const texture = new THREE.CanvasTexture(textCanvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(x, y, z);
                sprite.scale.set(textCanvas.width / 10, textCanvas.height / 10, 1);
                scene.add(sprite);
                labelObjects.push(sprite);
            });

            // --- Creazione link ---
            links.forEach(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);

                if (sourceNode && targetNode) {
                    const material = new THREE.LineBasicMaterial({ color: 0xaaaaaa, linewidth: 2 });
                    const geometry = new THREE.BufferGeometry().setFromPoints([sourceNode.object.position, targetNode.object.position]);
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    linkObjects.push(line);
                    link.object = line;
                }
            });

            // Posiziona la telecamera per visualizzare tutto il grafico
            camera.position.z = Math.max(
                ...nodeObjects.map(obj => obj.position.length())
            ) * 1.5;
            if (camera.position.z < 100) {
                camera.position.z = 100;
            }
            camera.lookAt(scene.position);
            
            console.log("Grafico disegnato con", nodes.length, "nodi e", links.length, "link.");
        }

        // --- Interazione con il mouse per rotazione e zoom ---
        let isMouseDown = false;
        let prevMouseX = 0, prevMouseY = 0;
        let rotationSpeed = 0.005;
        let zoomSpeed = 0.001;

        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            prevMouseX = event.clientX;
            prevMouseY = event.clientY;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const deltaX = event.clientX - prevMouseX;
                const deltaY = event.clientY - prevMouseY;

                // Rotazione attorno agli assi
                scene.rotation.y += deltaX * rotationSpeed;
                scene.rotation.x += deltaY * rotationSpeed;

                prevMouseX = event.clientX;
                prevMouseY = event.clientY;
            }
        });

        document.addEventListener('wheel', (event) => {
            camera.position.z += event.deltaY * zoomSpeed;
            if (camera.position.z < 10) camera.position.z = 10;
        });

        document.addEventListener('mouseover', (event) => {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(nodeObjects);
            
            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                const node = nodes.find(n => n.object === intersectedObject);
                if (node) {
                    infoPanel.style.display = 'block';
                    infoPanel.innerHTML = `
                        <strong>Nome:</strong> ${node.name}<br>
                        <strong>ID:</strong> ${node.id}<br>
                        <strong>Tipo:</strong> ${node.type}
                    `;
                    infoPanel.style.left = `${event.clientX + 15}px`;
                    infoPanel.style.top = `${event.clientY + 15}px`;
                }
            } else {
                infoPanel.style.display = 'none';
            }
        });

        // --- Ciclo di animazione ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        window.onload = function() {
            animate();
        };

    </script>
</body>
</html>
