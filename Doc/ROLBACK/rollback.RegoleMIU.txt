ROLBACK
C:\Progetti\EvolutiveSystem\MIU.Core\RegoleMIU.cs
// File: C:\Progetti\EvolutiveSystem_250604\MIU.Core\RegoleMIU.cs
// Data di riferimento: 4 giugno 2025
// Contiene la classe RegoleMIUManager per la gestione delle regole MIU e gli eventi correlati.
// CORREZIONE 17.6.25: Rimossa la direttiva 'using EvolutiveSystem.SQL.Core;' per eliminare la dipendenza inversa.
// MODIFICA 17.6.25: Adattato TrovaDerivazioneBFS e TrovaDerivazioneDFS per operare su stringhe standard (decompresse).
// NUOVA MODIFICA 19.6.25: Integrazione di MasterLog.Logger per sostituire Console.WriteLine e aggiunta LoggerInstance.
// CORREZIONE 20.6.25: AGGIUNTA EFFETTIVA DELLA PROPRIETA' LoggerInstance MANCANTE.
// NUOVA MODIFICA 20.6.25: Aggiornamento SolutionFoundEventArgs e logica BFS/DFS per persistenza completa.
// Data di riferimento: 20 giugno 2025 (Implementazione Strategia di Apprendimento - Prioritizzazione Regole)
// Contiene la classe RegoleMIUManager per la gestione delle regole MIU e gli eventi correlati.
// Aggiornato per includere la logica di apprendimento automatico basata sulle statistiche.
// Tutti i messaggi di output (Console.WriteLine, Logger.Log) sono ora in inglese.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text.RegularExpressions;
using MasterLog; // Required for your Logger class

namespace MIU.Core
{
    /// <summary>
    /// Struttura dati per un singolo passo nel percorso della soluzione.
    /// Contiene la stringa dello stato, l'ID della regola applicata per raggiungerlo
    /// e la stringa dello stato genitore.
    /// </summary>
    public class PathStepInfo
    {
        public string StateStringStandard { get; set; } // La stringa MIU standard (decompressa) per questo stato
        public long? AppliedRuleID { get; set; } // L'ID della regola applicata per arrivare a questo stato (null per lo stato iniziale)
        public string ParentStateStringStandard { get; set; } // La stringa MIU standard (decompressa) del genitore (null per lo stato iniziale)
    }

    // EventArgs per l'evento OnSolutionFound
    public class SolutionFoundEventArgs : EventArgs
    {
        public long SearchID { get; set; } // NEW: Search ID
        public string InitialString { get; set; } // This will be the original COMPRESSED string
        public string TargetString { get; set; } // This will be the target COMPRESSED string
        public bool Success { get; set; }
        public long ElapsedMilliseconds { get; set; } // Changed to long to match Stopwatch.ElapsedMilliseconds
        public long ElapsedTicks { get; set; }
        public List<PathStepInfo> SolutionPathSteps { get; set; } // NEW TYPE: list of PathStepInfo
        public int StepsTaken { get; set; } // Number of steps in the solution
        public long NodesExplored { get; set; } // Number of nodes explored during the search
        public int MaxDepthReached { get; set; } // Maximum depth reached

        // Constructor added to align with usage in Program.cs
        public SolutionFoundEventArgs(long searchID, long elapsedMilliseconds, long elapsedTicks, string initialString, string targetString, bool success, int stepsTaken, long nodesExplored, int maxDepthReached, List<PathStepInfo> solutionPathSteps)
        {
            SearchID = searchID;
            ElapsedMilliseconds = elapsedMilliseconds;
            ElapsedTicks = elapsedTicks;
            InitialString = initialString;
            TargetString = targetString;
            Success = success;
            StepsTaken = stepsTaken;
            NodesExplored = nodesExplored;
            MaxDepthReached = maxDepthReached;
            SolutionPathSteps = solutionPathSteps;
        }
    }

    // EventArgs per l'evento OnRuleApplied
    public class RuleAppliedEventArgs : EventArgs
    {
        public long SearchID { get; set; } // Added SearchID
        public long AppliedRuleID { get; set; }
        public string AppliedRuleName { get; set; }
        public string OriginalString { get; set; } // This will be the STANDARD string
        public string NewString { get; set; } // This will be the STANDARD string
        public int CurrentDepth { get; set; }

        // Constructor added to align with usage in Program.cs
        public RuleAppliedEventArgs(long searchId, long appliedRuleID, string appliedRuleName, string originalString, string newString, int currentDepth)
        {
            SearchID = searchId;
            AppliedRuleID = appliedRuleID;
            AppliedRuleName = appliedRuleName;
            OriginalString = originalString;
            NewString = newString;
            CurrentDepth = currentDepth;
        }
    }

    public static class RegoleMIUManager
    {
        // Proprietà statica per l'istanza del logger
        public static Logger LoggerInstance { get; set; }

        // Collezione statica di tutte le regole MIU disponibili.
        public static List<RegolaMIU> Regole { get; private set; } = new List<RegolaMIU>();

        // Eventi per notificare la soluzione trovata o l'applicazione di una regola.
        public static event EventHandler<SolutionFoundEventArgs> OnSolutionFound;
        public static event EventHandler<RuleAppliedEventArgs> OnRuleApplied;

        // Campo per memorizzare le statistiche delle regole caricate in memoria.
        // La chiave è l'ID della regola (long).
        private static Dictionary<long, RuleStatistics> _ruleStatistics;

        /// <summary>
        /// Imposta le statistiche delle regole che verranno utilizzate per la prioritizzazione.
        /// Questo metodo viene chiamato da Program.cs all'avvio.
        /// </summary>
        /// <param name="stats">Il dizionario di RuleStatistics.</param>
        public static void SetRuleStatistics(Dictionary<long, RuleStatistics> stats)
        {
            _ruleStatistics = stats;
            LoggerInstance?.Log(LogLevel.DEBUG, $"[RegoleMIUManager DEBUG] RuleStatistics set. Content: {_ruleStatistics?.Count ?? 0} items.");
        }

        /// <summary>
        /// Carica le regole MIU da una lista di stringhe formattate come output SQLiteSelect.
        /// Questo metodo è progettato per interfacciarsi con il formato stringa di SQLiteSchemaLoader.
        /// ATTENZIONE: Questo metodo assume un formato stringa specifico e non è robusto a cambiamenti.
        /// </summary>
        /// <param name="regoleRawData">Lista di stringhe, ogni stringa rappresenta una riga di dati delimitata da ';'.</param>
        public static void CaricaRegoleDaOggettoSQLite(List<string> regoleRawData)
        {
            Regole.Clear(); // Pulisce le regole esistenti prima di caricare le nuove

            foreach (string riga in regoleRawData)
            {
                string[] campi = riga.Split(';');
                if (campi.Length >= 5) // Assicurati che ci siano abbastanza campi
                {
                    try
                    {
                        // Assumiamo l'ordine: ID, Nome, Pattern, Sostituzione, Descrizione
                        long id = Convert.ToInt64(campi[0]);
                        string nome = campi[1].Trim();
                        string pattern = campi[2].Trim();
                        string sostituzione = campi[3].Trim();
                        string descrizione = campi[4].Trim();

                        Regole.Add(new RegolaMIU(id, nome, descrizione, pattern, sostituzione));
                    }
                    catch (Exception ex)
                    {
                        // Usa il LoggerInstance per il log degli errori
                        LoggerInstance?.Log(LogLevel.ERROR, $"[RegoleMIUManager ERROR] Error parsing rule row: {riga}. Details: {ex.Message}");
                    }
                }
            }
            LoggerInstance?.Log(LogLevel.DEBUG, $"[RegoleMIUManager DEBUG] Loaded {Regole.Count} rules from SQLite object.");
        }

        /// <summary>
        /// Carica le regole MIU da una lista di oggetti RegolaMIU.
        /// Questo metodo è pensato per essere utilizzato con l'output di MIURepository.LoadRegoleMIU().
        /// </summary>
        /// <param name="regoleMIU">Lista di oggetti RegolaMIU.</param>
        public static void CaricaRegoleDaOggettoRepository(List<RegolaMIU> regoleMIU)
        {
            Regole.Clear(); // Pulisce le regole esistenti prima di caricare le nuove
            Regole.AddRange(regoleMIU); // Aggiunge tutte le regole dalla lista fornita
            LoggerInstance?.Log(LogLevel.DEBUG, $"[RegoleMIUManager DEBUG] Loaded {Regole.Count} rules from Repository object.");
        }


        /// <summary>
        /// Applica le regole MIU a una stringa data in un ciclo, mostrando tutti i passaggi.
        /// Questa funzione opera su stringhe STANDARD (decompresse).
        /// </summary>
        /// <param name="initialStringStandard">La stringa iniziale standard (decompressa) a cui applicare le regole.</param>
        public static void ApplicaRegole(string initialStringStandard)
        {
            LoggerInstance?.Log(LogLevel.INFO, $"Initial string: {initialStringStandard}");
            string currentStringStandard = initialStringStandard;
            int step = 0;
            bool appliedAnyRule;

            do
            {
                appliedAnyRule = false;
                foreach (var rule in Regole)
                {
                    if (rule.TryApply(currentStringStandard, out string newStringStandard))
                    {
                        LoggerInstance?.Log(LogLevel.INFO, $"Step {step + 1}: Applied Rule '{rule.Nome}' ({rule.ID}) to '{currentStringStandard}' -> '{newStringStandard}'");
                        OnRuleApplied?.Invoke(null, new RuleAppliedEventArgs // Corrected: Added searchId parameter
                        (
                            0L, // Use 0L as searchId for standalone ApplicaRegole
                            rule.ID,
                            rule.Nome,
                            currentStringStandard, // STANDARD string
                            newStringStandard,    // STANDARD string
                            step
                        ));
                        currentStringStandard = newStringStandard;
                        appliedAnyRule = true;
                        step++;
                        break; // Applies only one rule per step for testing
                    }
                }
            } while (appliedAnyRule);

            LoggerInstance?.Log(LogLevel.INFO, $"Final result after {step} steps: {currentStringStandard}");
        }

        /// <summary>
        /// Implementazione della ricerca in profondità (DFS) per trovare una derivazione.
        /// Opera su stringhe STANDARD internamente, ma accetta/restituisce stringhe COMPRESSE.
        /// </summary>
        /// <param name="searchId">L'ID della ricerca corrente per la persistenza.</param>
        public static List<PathStepInfo> TrovaDerivazioneDFS(long searchId, string startStringCompressed, string targetStringCompressed, long maxProfondita)
        {
            // Decompress the initial and target strings for internal search
            string startStringStandard = MIUStringConverter.DeflateMIUString(startStringCompressed);
            string targetStringStandard = MIUStringConverter.DeflateMIUString(targetStringCompressed);

            // Stack for DFS: (current standard state, list of PathStepInfo up to here)
            Stack<(string currentStandard, List<PathStepInfo> currentPath)> stack = new Stack<(string, List<PathStepInfo>)>();
            HashSet<string> visitedStandard = new HashSet<string>(); // To track already visited standard states
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();

            // Add the initial state to the path
            var initialPathStep = new PathStepInfo
            {
                StateStringStandard = startStringStandard,
                AppliedRuleID = null, // No rule applied for the initial state
                ParentStateStringStandard = null // No parent for the initial state
            };
            stack.Push((startStringStandard, new List<PathStepInfo> { initialPathStep }));
            visitedStandard.Add(startStringStandard);

            int nodesExplored = 0;
            int maxDepthReached = 0;

            LoggerInstance?.Log(LogLevel.INFO, $"[DFS] Starting search from '{startStringStandard}' to '{targetStringStandard}' (Max Depth: {maxProfondita})");

            while (stack.Count > 0)
            {
                nodesExplored++;
                var (currentStandard, currentPath) = stack.Pop();
                maxDepthReached = Math.Max(maxDepthReached, currentPath.Count - 1); // Depth is path length - 1

                if (currentStandard == targetStringStandard)
                {
                    stopwatch.Stop();
                    // The path is already in PathStepInfo with standard strings
                    OnSolutionFound?.Invoke(null, new SolutionFoundEventArgs(
                        searchId, // Pass the search ID
                        stopwatch.ElapsedMilliseconds, // Corrected to long
                        stopwatch.ElapsedTicks,
                        startStringCompressed, // Original COMPRESSED string
                        targetStringCompressed, // Target COMPRESSED string
                        true, // Success
                        currentPath.Count - 1, // Full path already ready
                        nodesExplored,
                        maxDepthReached,
                        currentPath // Complete path already ready
                    ));
                    LoggerInstance?.Log(LogLevel.INFO, $"[DFS] Solution found: '{startStringStandard}' -> '{targetStringStandard}'. Steps: {currentPath.Count - 1}, Nodes explored: {nodesExplored}. Time: {stopwatch.ElapsedMilliseconds} ms.");
                    return currentPath; // Returns path in PathStepInfo
                }

                if (currentPath.Count - 1 >= maxProfondita) continue; // Max depth reached

                // NEW: Order rules based on EffectivenessScore for DFS
                var orderedRules = Regole.OrderByDescending(rule =>
                {
                    if (_ruleStatistics != null && _ruleStatistics.TryGetValue(rule.ID, out RuleStatistics stats))
                    {
                        return stats.EffectivenessScore;
                    }
                    // Assign a base score for rules without statistics (e.g., 0.0 or a small value)
                    return 0.0;
                }).ToList();

                foreach (var rule in orderedRules) // Iterate over ordered rules
                {
                    // TryApply operates on STANDARD strings
                    if (rule.TryApply(currentStandard, out string newStringStandard))
                    {
                        // Pass the searchId to the RuleAppliedEventArgs constructor
                        OnRuleApplied?.Invoke(null, new RuleAppliedEventArgs(
                            searchId,
                            rule.ID,
                            rule.Nome,
                            currentStandard, // STANDARD string
                            newStringStandard,    // STANDARD string
                            currentPath.Count - 1 // Current depth
                        ));

                        if (!visitedStandard.Contains(newStringStandard))
                        {
                            visitedStandard.Add(newStringStandard);
                            // Create a new step for the path
                            var newPathStep = new PathStepInfo
                            {
                                StateStringStandard = newStringStandard,
                                AppliedRuleID = rule.ID,
                                ParentStateStringStandard = currentStandard
                            };
                            List<PathStepInfo> newPath = new List<PathStepInfo>(currentPath) { newPathStep };
                            stack.Push((newStringStandard, newPath));
                            LoggerInstance?.Log(LogLevel.DEBUG, $"[DFS] Added new state: '{newStringStandard}' (from '{currentStandard}' with rule '{rule.Nome}'). Depth: {currentPath.Count}. Stack size: {stack.Count}");
                        }
                    }
                }
            }

            stopwatch.Stop();
            OnSolutionFound?.Invoke(null, new SolutionFoundEventArgs(
                searchId, // Pass the search ID
                stopwatch.ElapsedMilliseconds,
                stopwatch.ElapsedTicks,
                startStringCompressed, // Original COMPRESSED string
                targetStringCompressed, // Target COMPRESSED string
                false, // Failure
                -1, // Steps taken is not applicable for failure
                nodesExplored,
                maxDepthReached,
                null // Null path if not found
            ));
            LoggerInstance?.Log(LogLevel.INFO, $"[DFS] No solution found: '{startStringStandard}' -> '{targetStringStandard}'. Nodes explored: {nodesExplored}, Max Depth: {maxDepthReached}. Time: {stopwatch.ElapsedMilliseconds} ms.");
            return null; // No derivation found
        }


        /// <summary>
        /// Implementazione della ricerca in ampiezza (BFS) per trovare la derivazione più breve.
        /// Opera su stringhe STANDARD internamente, ma accetta/restituisce una lista di PathStepInfo.
        /// </summary>
        /// <param name="searchId">L'ID della ricerca corrente per la persistenza.</param>
        public static List<PathStepInfo> TrovaDerivazioneBFS(long searchId, string startStringCompressed, string targetStringCompressed, long maxPassi)
        {
            // Decompress the initial and target strings for internal search
            string startStringStandard = MIUStringConverter.DeflateMIUString(startStringCompressed);
            string targetStringStandard = MIUStringConverter.DeflateMIUString(targetStringCompressed);

            // Queue for BFS: (current standard state, list of PathStepInfo up to here)
            Queue<(string currentStandard, List<PathStepInfo> currentPath)> queue = new Queue<(string, List<PathStepInfo>)>();
            HashSet<string> visitedStandard = new HashSet<string>(); // To track already visited standard states
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();

            // Add the initial state to the path
            var initialPathStep = new PathStepInfo
            {
                StateStringStandard = startStringStandard,
                AppliedRuleID = null, // No rule applied for the initial state
                ParentStateStringStandard = null // No parent for the initial state
            };
            queue.Enqueue((startStringStandard, new List<PathStepInfo> { initialPathStep }));
            visitedStandard.Add(startStringStandard);

            int nodesExplored = 0;
            int maxDepthReached = 0;

            LoggerInstance?.Log(LogLevel.DEBUG, $"[BFS] Starting search from '{startStringStandard}' to '{targetStringStandard}' (Max Steps: {maxPassi})");

            while (queue.Count > 0)
            {
                nodesExplored++;
                var (currentStandard, currentPath) = queue.Dequeue();
                maxDepthReached = Math.Max(maxDepthReached, currentPath.Count - 1); // Depth is path length - 1

                if (currentStandard == targetStringStandard)
                {
                    stopwatch.Stop();
                    // The path is already in PathStepInfo with standard strings
                    OnSolutionFound?.Invoke(null, new SolutionFoundEventArgs(
                        searchId, // Pass the search ID
                        stopwatch.ElapsedMilliseconds, // Corrected to long
                        stopwatch.ElapsedTicks,
                        startStringCompressed, // Original COMPRESSED string
                        targetStringCompressed, // Target COMPRESSED string
                        true, // Success
                        currentPath.Count - 1, // Steps taken (excluding initial state)
                        nodesExplored,
                        maxDepthReached,
                        currentPath // Complete path already ready
                    ));
                    LoggerInstance?.Log(LogLevel.INFO, $"[BFS] Solution found: '{startStringStandard}' -> '{targetStringStandard}'. Steps: {currentPath.Count - 1}, Nodes explored: {nodesExplored}. Time: {stopwatch.ElapsedMilliseconds} ms.");
                    return currentPath; // Returns path in PathStepInfo
                }

                if (currentPath.Count - 1 >= maxPassi)
                {
                    // LoggerInstance?.Log(LogLevel.DEBUG, $"[BFS] Max depth ({maxPassi}) reached for '{currentStandard}'. Skipping exploration.");
                    continue; // Max depth reached
                }

                // NEW: Order rules based on EffectivenessScore
                var orderedRules = Regole.OrderByDescending(rule =>
                {
                    if (_ruleStatistics != null && _ruleStatistics.TryGetValue(rule.ID, out RuleStatistics stats))
                    {
                        return stats.EffectivenessScore;
                    }
                    // Assign a base score for rules without statistics (e.g., 0.0 or a small value)
                    // This still considers them, but after those with proven effectiveness.
                    return 0.0;
                }).ToList();


                foreach (var rule in orderedRules) // Iterate over ordered rules
                {
                    // TryApply operates on STANDARD strings
                    if (rule.TryApply(currentStandard, out string newStringStandard))
                    {
                        // Pass the searchId to the RuleAppliedEventArgs constructor
                        OnRuleApplied?.Invoke(null, new RuleAppliedEventArgs(
                            searchId,
                            rule.ID,
                            rule.Nome,
                            currentStandard, // STANDARD string
                            newStringStandard,    // STANDARD string
                            currentPath.Count - 1 // Current depth
                        ));

                        if (!visitedStandard.Contains(newStringStandard))
                        {
                            visitedStandard.Add(newStringStandard);
                            // Create a new step for the path
                            var newPathStep = new PathStepInfo
                            {
                                StateStringStandard = newStringStandard,
                                AppliedRuleID = rule.ID,
                                ParentStateStringStandard = currentStandard
                            };
                            List<PathStepInfo> newPath = new List<PathStepInfo>(currentPath) { newPathStep };
                            queue.Enqueue((newStringStandard, newPath));
                            LoggerInstance?.Log(LogLevel.DEBUG, $"[BFS] Added new state: '{newStringStandard}' (from '{currentStandard}' with rule '{rule.Nome}'). Depth: {currentPath.Count}. Queue: {queue.Count}");
                        }
                        else
                        {
                            // LoggerInstance?.Log(LogLevel.DEBUG, $"[BFS] State '{newStringStandard}' already visited. Skipping.");
                        }
                    }
                }
            }

            stopwatch.Stop();
            OnSolutionFound?.Invoke(null, new SolutionFoundEventArgs(
                searchId, // Pass the search ID
                stopwatch.ElapsedMilliseconds,
                stopwatch.ElapsedTicks,
                startStringCompressed, // Original COMPRESSED string
                targetStringCompressed, // Target COMPRESSED string
                false, // Failure
                -1, // Steps taken is not applicable for failure
                nodesExplored,
                maxDepthReached,
                null // Null path if not found
            ));
            LoggerInstance?.Log(LogLevel.INFO, $"[BFS] No solution found: '{startStringStandard}' -> '{targetStringStandard}'. Nodes explored: {nodesExplored}, Max Depth: {maxDepthReached}. Time: {stopwatch.ElapsedMilliseconds} ms.");
            return null; // No derivation found
        }
    }
}
